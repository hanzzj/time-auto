Guard 规定了哪些时钟条件下可以跳转但是并不是一定要跳转，是充分而不必要条件,允许存在延迟。

idle 空转  taken 接受 

observer 附加自动机，再不改变系统状态条件下检测事件。

E<> ϕ表示在满足ϕ条件/到达ϕ状态的状态E。

在没有不变量X<=3作为上界约束的情况下，复位RESET执行延迟可能达到很大的时间单元。可能是检测时间没有不变量作为严格要求的原因，guard的要求可能不够严格。

时钟信号量可以看作一个约束条件，必须满足时钟信号量的不等式才能进行向下一状态迁移。时钟信号量与先后时间无必然关系，但与持续时间时一致的。在起始标志事件发生之后持续了多长时间才发生第二个时间，那么时钟信号量的值就对应多少。没有发生状态迁移/信号事件发生 时可认为时钟信号量一直在持续增长。

带问号？的sync表示等待该信息号量传入/该事件发生才会迁移到下一状态，否则就移值处于等待状态。而带感叹号！的sync表示向其他系统广播发出该信号量，在该事件已经发生后。

ATM在取钱时首先看自己机子里的钱是否够10，然后再向银行发出查询该用户余额是否够10的查询请求。

arm手臂的grip动作循环周期是10ms，也就是说用不变量<=10来约束在10ms内迁移到下一状态。n:=0表示重置reset操作，将时钟信号量置0，以便进行下一次完整操作。

x<2时会产生死锁，定义迁移，死锁是状态不会向前迁移，之后时间段是不会有新的事件发生。在第三次实验中，观测x>=2之后有没有可能发生reset，若能就没有死锁。而在加上x<=3时，有可能x初始时>3导致一直没有reset操作。
如果某一状态不能从状态本身或任何状态转换的传出操延误的下一步迁移状态，称呼其为死锁状态。（new-tutorial给出的定义）由此来分析第三此实验中可能存在的死锁状况。
 The invariant is a progress condition: the system is not allowed to stay in the state more than 3 time units, so that the transition has to be taken and the clock reset in our example。
 现在，如果我们移除不变量，并将guard更改为x>=2和x<=3，你也许认为它和以前一样，但事实并非如此！系统没有任何进展情况。图7显示了发生事件：系统可能进行与以前相同的转换，但是死锁可能也会发生。如果在3次之后没有进行转换，系统可能会卡住。事实上，系统验证属性A[] not deadlock会失败。即在时钟信号大于3time单位，，它会一直增长，永远不会同时满足小于等于3和大于等于3，系统不会发生状态迁移和产生新的信号量，陷入死锁。这里就是区分了invariant和guard。invariant不等同于guard，不会强制满足它定义的约束，在可以满足的条件下可以去满足，在不满足的条件下可以忽略而进行迁移。而gurad要求必须满足，不满足时就必须处于idle状态，也不会发出新的信号量。
